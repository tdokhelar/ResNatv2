<?php

namespace App\Repository;

use App\Document\ElementStatus;
use App\Document\ModerationState;
use Doctrine\ODM\MongoDB\Repository\DocumentRepository;
/**
 * ElementRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ElementRepository extends DocumentRepository
{
    protected $config = null;

    private function getConfig()
    {
        if (!$this->config) $this->config = $this->getDocumentManager()->get('Configuration')->findConfiguration();
        return $this->config;
    }

    public function findDuplicatesFor($element, $elementIdsToIgnore = [], $sourceToDetectWith = [])
    {
        $forNewlyCreatedElement = $element->getId() == null;

        $config = $this->getConfig()->getDuplicates();
        $qb = $this->query('Element');
        $qb->limit(20); //to avoid timeout

        // GEO SPATIAL QUERY
        $distance = $config->getRangeInMeters();
        if ($forNewlyCreatedElement) {
            $distance = 2 * $distance; // wider for manual check
        } else {
            $city = strtolower($element->getAddress()->getAddressLocality());
            if (in_array($element->getAddress()->getDepartmentCode(), ['75', '92', '93', '94'])
                || in_array($city, ['marseille', 'lyon', 'bordeaux', 'lille', 'montpellier', 'strasbourg', 'nantes', 'nice'])) {
                $distance = $distance / 2; // narrow down in big cities, only working for France
            }
        }
        $radius = $distance / 110000; // convert meters in degrees
        if ($element->getGeo()->getLatitude() && $element->getGeo()->getLongitude())
            $qb->field('geo')->withinCenter((float) $element->getGeo()->getLatitude(), (float) $element->getGeo()->getLongitude(), $radius);

        $qb->field('status')->gt(ElementStatus::ModifiedPendingVersion);
        // We only want to have pairs of duplicates, so restrict to non potential duplicates
        $qb->field('moderationState')->notEqual(ModerationState::PotentialDuplicate);

        $qb->field('id')->notIn(array_merge([$element->getId()], $element->getNonDuplicatesIds(), $elementIdsToIgnore));

        if (count($sourceToDetectWith)) {
            $qb->field('sourceKey')->in($sourceToDetectWith);
        }

        // Text Search
        $result1 = [];
        if ($config->getUseGlobalSearch()) {
            $qbText = clone $qb;
            $qbText = $this->queryText($qbText, $element->getName());
            $result1 = $this->queryToArray($qbText, true);
        }
        // Field Search
        $result2 = [];
        if (count($config->getFieldsToBeUsedForComparaison())) {
            $subQueriesCount = 0;
            foreach($config->getFieldsToBeUsedForComparaison() as $field) {
                if ($element->getProperty($field)) {
                    $subQueriesCount++;
                    $qb->addOr($qb->expr()->field("data.$field")->equals($element->getProperty($field)));
                    if ($field == 'email') {
                        $qb->addOr($qb->expr()->field("$field")->equals($element->getProperty($field)));
                    }
                }
            }
            if ($subQueriesCount > 0) $result2 = $qb->hydrate(false)->getArray();
        }
        return $result1 + $result2; // + operator will make the array unique cause each key is an element id
    }

    public function findWhithinBoxes($bounds, $request, $ontology, $isAdmin = false)
    {
        $qb = $this->query('Element');

        $status = ('false' === $request->get('pendings')) ? ElementStatus::AdminValidate : ElementStatus::PendingModification;
        $this->filterVisibles($qb, $status);

        // get elements within box
        foreach ($bounds as $key => $bound) {
            if (4 == count($bound)) {
                $qb->addOr($qb->expr()->field('geo')->withinBox((float) $bound[1], (float) $bound[0], (float) $bound[3], (float) $bound[2]));
            }
        }

        if ($request) {
            $this->filterWithRequest($qb, $request);
        }
        $this->selectJson($qb, $ontology, $isAdmin);

        // execute request
        $results = $this->queryToArray($qb);

        return $results;
    }

    public function findElementsWithText($text, $fullRepresentation = true, $isAdmin = false)
    {
        $qb = $this->query('Element');

        $this->queryText($qb, $text);
        $this->filterVisibles($qb);

        $this->selectJson($qb, $fullRepresentation, $isAdmin);

        return $this->queryToArray($qb);
    }

    public function findElementNamesWithText($text, $excludeId)
    {
        $qb = $this->query('Element');

        $this->queryText($qb, $text);
        $this->filterVisibles($qb);
        $qb->field('id')->notEqual($excludeId);
        $qb->select('name')->limit(20);
        try {
            return $qb->getArray();
        } catch(\Throwable $e) {
            if (strpos($e->getMessage(), 'text index') > -1) {
                $this->fixSearchIndex();
                return $qb->getArray();
            }
        }
    }

    public function findPendings($getCount = false)
    {
        $qb = $this->query('Element');

        $qb->field('status')->in([ElementStatus::PendingAdd, ElementStatus::PendingModification]);
        if ($getCount) {
            $qb->count();
        }

        return $qb->execute();
    }

    public function findModerationNeeded($getCount = false, $moderationState = null)
    {
        $qb = $this->query('Element');

        if (null != $moderationState) {
            $qb->field('moderationState')->equals($moderationState);
        } else {
            $qb->field('moderationState')->notIn([ModerationState::NotNeeded, ModerationState::PotentialDuplicate]);
        }
        $qb->field('status')->gte(ElementStatus::PendingModification);

        if ($getCount) {
            $qb->count();
        }

        return $qb->execute();
    }

    public function findValidated($getCount = false)
    {
        $qb = $this->query('Element');

        $qb->field('status')->gt(ElementStatus::PendingAdd);
        if ($getCount) {
            $qb->count();
        }

        return $qb->execute();
    }

    public function findVisibles($getCount = false, $excludeImported = false, $limit = null, $skip = null, $forSeo = false)
    {
        $qb = $this->query('Element');

        $qb = $this->filterVisibles($qb);
        if ($excludeImported) {
            $qb->field('isExternal')->notEqual(true);
        }
        if ($limit) {
            $qb->limit($limit);
        }
        if ($skip) {
            $qb->skip($skip);
        }
        if ($getCount) {
            $qb->count();
        }
        if ($forSeo) {
            return $qb->select('id', 'updatedAt')->getArray();
        } else {
            return $qb->execute();
        }
    }

    public function findAllPublics($ontology, $isAdmin, $request = null)
    {
        $qb = $this->query('Element');

        $qb = $this->filterVisibles($qb);
        $qb->field('moderationState')->equals(ModerationState::NotNeeded);

        if ($request) {
            $this->filterWithRequest($qb, $request);
        }
        $this->selectJson($qb, $ontology, $isAdmin);

        return $this->queryToArray($qb);
    }

    public function findAllElements($limit = null, $skip = null, $getCount = false)
    {
        $qb = $this->query('Element');

        if ($limit) {
            $qb->limit($limit);
        }
        if ($skip) {
            $qb->skip($skip);
        }
        if ($getCount) {
            $qb->count();
        }

        return $qb->execute();
    }

    public function findModerationElementToNotifyToUser($user)
    {
        $qb = $this->query('Element');
        $qb->field('moderationState')->notEqual(ModerationState::NotNeeded);
        $qb->field('status')->gt(ElementStatus::AdminRefused);
        $optionsIds = [];
        foreach($user->getWatchModerationOnlyWithOptions() as $option)
            $optionsIds[] = $option->getId();
        if (count($optionsIds)> 0)
            $qb->field('optionValues.optionId')->in($optionsIds);
        if ($user->getWatchModerationOnlyWithPostCodesRegexp()) {
            $regexp = $user->getWatchModerationOnlyWithPostCodesRegexp();
            $qb->field('address.postalCode')->equals(new \MongoRegex($regexp));
        }

        return $qb->count()->execute();
    }

    // Sometimes, don't know why, the text index is missing
    public function fixSearchIndex()
    {
        $db = $this->getDocumentManager()->getDB();
        $db->command(["deleteIndexes" => 'Element',"index" => "search_index"]);
        $db->selectCollection('Element')->createIndex(['name' => 'text'], [
            'name' => "search_index",
            "default_language" => $this->getConfig()->getLocale(),
            "weights" => ['name' => 1]
        ]);
    }

    private function queryToArray($qb, $hydrate = false)
    {
        try {
            return $qb->hydrate($hydrate)->execute()->toArray();
        }
        catch(\Throwable $e) {
            if (strpos($e->getMessage(), 'text index') > -1) {
                $this->fixSearchIndex();
                return $qb->hydrate($hydrate)->execute()->toArray();
            }
        }
    }

    private function filterWithRequest($qb, $request)
    {
        $categoriesIds = $request->get('categories');
        if ($categoriesIds) {
            if (!is_array($categoriesIds)) {
                $categoriesIds = explode(',', $categoriesIds);
            }
            $categoriesIds = array_map(function ($el) { return (float) $el; }, $categoriesIds);
            $qb->field('optionValues.optionId')->in($categoriesIds);
        }

        if ($request->get('excludeExternal')) {
            $qb->field('isExternal')->notEqual(true);
        }

        $stampsIds = $request->get('stampsIds');
        if ($stampsIds) {
            if (!is_array($stampsIds)) {
                $stampsIds = explode(',', $stampsIds);
            }
            $qb->field('stamps.id')->in($stampsIds);
        }

        $limit = $request->get('limit');
        if ($limit && $limit > 0) {
            $qb->limit($limit);
        }
    }

    private function queryText($qb, $text)
    {
        $config = $this->getDocumentManager()->get('Configuration')->findConfiguration();
        if ($config->getSearchExcludingWords()) {
            $text = $text.' --'.str_replace(',', ' --', $config->getSearchExcludingWords());
        }
        return $qb->text($text)->sortMeta('score', 'textScore');
    }

    private function filterVisibles($qb, $status = ElementStatus::PendingModification)
    {
        // fetching pendings and validated
        $qb->field('status')->gte($status);
        // removing element withtout category or withtout geolocation
        $qb->field('moderationState')->notIn([ModerationState::GeolocError, ModerationState::NoOptionProvided]);

        return $qb;
    }

    private function selectJson($qb, $ontology, $isAdmin)
    {
        switch($ontology) {
            case 'gogofull':
                $qb->select('baseJson');
                if ($isAdmin) {
                    $qb->select('adminJson');
                }
                break;

            case 'gogocompact':
                $qb->select('compactJson');
                break;

            case 'gogosync':
                $qb->select('id', 'updatedAt');
                break;
        }
    }

    public function findElementsOwnedBy($userEmail)
    {
        $qb = $this->query('Element');

        $qb->field('userOwnerEmail')->equals($userEmail);
        $qb->field('status')->notEqual(ElementStatus::ModifiedPendingVersion);
        $qb->sort('updatedAt', 'DESC');

        return $qb->execute();
    }

    // Used by newsletter
    public function findWithinCenterFromDate($lat, $lng, $distance, $date, $limit = null)
    {
        $qb = $this->query('Element');
        $radius = $distance / 110;
        $qb->field('geo')->withinCenter((float) $lat, (float) $lng, $radius);
        $qb->field('createdAt')->gt($date);
        $qb = $this->filterVisibles($qb);
        if ($limit) {
            $qb->limit($limit);
        }

        return $qb->execute();
    }

    public function findStampedWithId($stampId)
    {
        return $this->query('Element')
            ->field('stamps.id')->in([(float) $stampId])
            ->getIds();
    }

    public function findOriginalElementOfModifiedPendingVersion($element)
    {
        $qb = $this->query('Element');
        $qb->field('modifiedElement')->references($element);

        return $qb->getQuery()->getSingleResult();
    }

    public function findDataCustomProperties()
    {
        if ($_ENV['MONGO_VERSION'] == 4) {
            // Run this command manually cause objectToArray has not yet been imlpement in Doctrine MongoDB (01/2021)
            $collection = $this->getDocumentManager()->getCollection('Element');
            $result = $collection->aggregate([
                ['$project' => ["arrayofkeyvalue" => ['$objectToArray' => '$data']]],
                ['$unwind' => '$arrayofkeyvalue'],
                ['$group' => [
                    "_id" => null,
                    "allkeys" => ['$addToSet' => '$arrayofkeyvalue.k']
                ]]
                ], ['cursor' => true]);
            return $result['result'][0]['allkeys'] ?? [];
        } else {
            $result =  $this->getDocumentManager()->getDB()->execute("
                var props = [];
                db.Element.find({}).forEach(function(e) {
                    for(var prop in e.data) {
                        if (props.indexOf(prop) == -1) props.push(prop);
                    }
                });
                return props;");
            return $result['retval'];
        }
    }

    public function findAllCustomProperties()
    {
        $dataProperties = $this->findDataCustomProperties();
        $allProperties = [];
        foreach ($dataProperties as $prop) {
            $allProperties[] = $prop;
        }

        $formProperties = $this->findFormProperties();

        return array_unique(array_merge($allProperties, $formProperties));
    }

    public function findFormProperties()
    {
        $formProperties = [];
        $propTypeToIgnore = ['separator', 'header', 'address', 'title', 'taxonomy', 'openhours'];
        $config = $this->getDocumentManager()->get('Configuration')->findConfiguration();
        foreach ($config->getElementFormFields() as $key => $field) {
            if (property_exists($field, 'name') && !in_array($field->type, $propTypeToIgnore)) {
                $formProperties[] = $field->name;
            }
        }

        return $formProperties;
    }

    public function findDeletedElementsByImportIdCount()
    {
        $builder = $this->createAggregationBuilder('App\Document\Element');
        $builder
          ->match()
            ->field('status')->lte(ElementStatus::AdminRefused)
          ->group()
              ->field('_id')
              ->expression('$source')
              ->field('count')
              ->sum(1)
        ;
        $queryResult = $builder->execute();
        $result = [];
        foreach ($queryResult as $key => $value) {
            if (!empty($id))
                $result[$value['_id']['$id']] = $value['count'];
        }

        return $result;
    }

    public function findElementsThatNeedToBeRefreshed($much=false)
    {
        $config = $this->getConfig();
        $now = new \Datetime();
        
        $maxDaysBeforeSendingRefreshNeededMail = $config->getMaxDaysBeforeSendingRefreshNeededMail();
        if ($much) {
            $maxDaysBeforeSendingRefreshNeededMail = $config->getMaxDaysBeforeSendingRefreshMuchNeededMail();
        }
        
        $UpdatedAtDateSinceRefreshIsNeeded = $now->modify('-' . $maxDaysBeforeSendingRefreshNeededMail . 'days');

        $qb = $this->query('Element');
        $qb->field('status')->gte(ElementStatus::AdminValidate);
        $qb->field('updatedAt')->lt($UpdatedAtDateSinceRefreshIsNeeded);
        $qb->addOr($qb->expr()->field('lastRefreshNeededMailSent')->exists(false));
        $qb->addOr($qb->expr()->field('lastRefreshNeededMailSent')->lt($UpdatedAtDateSinceRefreshIsNeeded));

        return $qb->execute();

        return $result;
    }
    
    public function findElementsThatMuchNeedToBeRefreshed()
    {
        return $this->findElementsThatNeedToBeRefreshed(true);
    }

}
